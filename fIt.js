// Generated by CoffeeScript 1.3.3

/*
fIt.js 0.000001
(c) yeah
fIt can be distributed, dissected, and dismantled. It cannot be used though.
*/


(function() {
  var E, F, Utils, exports, fIt, prefIt, self,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  self = this;

  prefIt = self.fIt;

  /*
  Reference to fIt for later use
  */


  fIt = function(obj) {
    if (obj instanceof fIt) {
      return obj;
    }
    if (!(this instanceof fIt)) {
      return new fIt(obj);
    }
    return this._wrapped = obj;
  };

  /*
  Export for Node.js when on server, or assign to window for browser
  */


  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = fIt;
    }
    exports.fIt = fIt;
  } else {
    self.fIt = fIt;
  }

  /*
  Version
  */


  fIt.VERSION = '0.01';

  F = fIt;

  /*
  Define some useful utility shortcuts
  */


  Utils = F.Utils = {};

  /*
  Extend object a with properties of object b
  */


  Utils.extend = function(a, b) {
    var key, val;
    for (key in b) {
      val = b[key];
      if (val === void 0) {
        delete a[key];
      } else if ((val !== "constructor") || (a !== window)) {
        a[key] = val;
      }
    }
    return a;
  };

  /*
  Derived from _.each
  */


  Utils.nativeForEach = Array.prototype.forEach;

  Utils["break"] = {};

  Utils.each = function(obj, iterator, context) {
    var i, item, key, val, _i, _len;
    if (obj === null) {
      return;
    }
    if (this.nativeForEach && obj.forEach === this.nativeForEach) {
      return obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {
        item = obj[i];
        if (iterator.call(context, obj[i], obj) === Utils["break"]) {
          return;
        }
      }
    } else {
      for (key in obj) {
        val = obj[key];
        if (iterator.call(context, obj[key], key, obj) === Utils["break"]) {
          return;
        }
      }
    }
  };

  /*
  Get an objects keys.
  */


  Utils.keys = function(obj) {
    var key, val, _results;
    if (obj.keys) {
      return obj.keys;
    }
    _results = [];
    for (key in obj) {
      val = obj[key];
      _results.push(key);
    }
    return _results;
  };

  /*
  Mathematical version of max without comparisons
  Only works on 32 bit numbers. Basically useless.
  You know what works, Math.max, try it.
  */


  Utils.max = function(a, b) {
    var c, k;
    c = a - b;
    k = (c>>31) & 0x1;
    return a - k * c;
  };

  /*
  A collection of esoteric junk
  */


  E = F.Esoteric = {};

  /*
  Map permutations of keys with their letters
  For instance, on a phone number pad, digits map to letters
  2 -> [a, b, c]
  23 -> [ad, ae, af, bd, be, bf, cd, ce, cf]
  */


  E.mapKeys = function(keys, chars, type) {
    var first, letter, letters, rest, ret, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (type == null) {
      type = "r";
    }
    switch (type) {
      case 'r':
        ret = [];
        if (chars.length < 1) {
          return [''];
        }
        first = chars[0];
        rest = chars.slice(1);
        letters = keys[first];
        if (!letters) {
          _ref = this.mapKeys(keys, rest, 'r');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            y = _ref[_i];
            ret.push(first + y);
          }
        } else {
          _ref1 = keys[first];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            letter = _ref1[_j];
            _ref2 = this.mapKeys(keys, rest, 'r');
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              y = _ref2[_k];
              ret.push(letter + y);
            }
          }
        }
        return ret;
    }
  };

  /*
  Given an array representing integer values over time, calculate
  the maximum single sell profit, assuming that you may select 
  at most once and deselect at most once over time.
  
  For example, given the values
  
  2, 7, 1, 8, 2, 8, 4, 5, 0, 4, 9, 5
  
  The max profit is 9, by selecting at 8 deselecting at 10
  Therefore the return values are (9, [8, 10])
  */


  E.maxProfit = function(values) {
    var i, lowHigh, min, profit, val, _i, _len;
    if (!values) {
      return values;
    }
    if (values.length === 1) {
      return [values[0], [0, 0]];
    }
    min = values[0];
    profit = 0;
    lowHigh = [0, 0];
    for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
      val = values[i];
      if (val < min) {
        min = val;
        lowHigh[0] = i;
      }
      if (val - min > profit) {
        profit = val - min;
        lowHigh[1] = i;
      }
    }
    return [profit, lowHigh];
  };

  /*
  F(n) = F(n-1) + F(n-2)
  */


  E.fibonacci = function(n, type) {
    var a, b, c, fib, i, memo, _i;
    if (type == null) {
      type = 'i';
    }
    switch (type) {
      case 'i':
        if (n < 2) {
          return n;
        }
        a = 0;
        b = 1;
        for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
          c = a + b;
          a = b;
          b = c;
        }
        return a;
      case 'r':
        fib = function(f) {
          if (f < 2) {
            return f;
          }
          return fib(f - 1) + fib(f - 2);
        };
        return fib(n);
      case 'm':
        memo = {
          0: 0,
          1: 1
        };
        fib = function(f) {
          if (f > 1) {
            if (__indexOf.call(Utils.keys(memo), f) < 0) {
              memo[f] = fib(f - 1) + fib(f - 2);
            }
          }
          return memo[f];
        };
        return fib(n);
    }
  };

  /*
  Product of all positive integers less than or equal to n
  */


  E.factorial = function(n, type) {
    var fact, i, _i;
    if (type == null) {
      type = 'i';
    }
    switch (type) {
      case 'i':
        if (n < 2) {
          return 1;
        }
        fact = 1;
        for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
          fact = fact * i;
        }
        return fact;
      case 'r':
        fact = function(f) {
          if (f < 2) {
            return 1;
          }
          return fact(f - 1) * f;
        };
        return fact(n);
    }
  };

  /*
  In mathematics, Pascal's triangle is a triangular array of the 
  binomial coefficients. Have I ever needed to know this? Never.
  That's why it's here, in recursive and iterative forms, wow.
  Is there a use for it? Maybe, look at chess.
  */


  E.pascalsTriangle = function(n, type) {
    var i, j, l, res, row, _i, _j, _ref, _ref1;
    if (type == null) {
      type = 'i';
    }
    switch (type) {
      case 'i':
        res = [];
        l = [1];
        res.push(l);
        if (n > 1) {
          for (i = _i = 1, _ref = n - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            row = [1];
            for (j = _j = 0, _ref1 = l.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              if (l[j + 1]) {
                row.push(l[j] + l[j + 1]);
              }
            }
            row.push(1);
            l = row;
            res.push(l);
          }
        }
        return res;
    }
  };

}).call(this);
